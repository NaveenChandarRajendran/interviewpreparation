The objects are referance

---------------------------------------------------------------
Shallow copy
---------------------------------------------------------------
const copy = {...user}; //But this will not copy the nested objects.Its still shared

---------------------------------------------------------------
Deep copy
---------------------------------------------------------------
const deep = JSON.parse(JSON.stringify(user));

---------------------------------------------------------------
Object Freeze and Sealing
---------------------------------------------------------------

Object.freeze(obj); //this object does not have add/update/delete
Object.seal(obj); //update allowed

Difference between == and === for objects?
if we try {} == {} it will be false.
The objects are compared by the referance not by value
What is this inside an object?
this is refers to the object which is invoked my method
---------------------------------------------------------------
Execution Context
---------------------------------------------------------------

In Environment in which how the javascript code is executed

It has two types
1. Global Execution Context
    - It defers the global variables,functions this(window) etc
2. Function Execution Context
    - It creates everytime within the function call

It has two types in Phases
1.Memory creation phase (Hoisting)
    - JS scans code and allocate the Memory
    variable -> undefiend
    functions -> full function definition
    let/cont -> store with uninitialzied
2.Execution Phases
    Executing the code

Common Tricky Interview Question
console.log(x);

function foo() {
  console.log(x);
  var x = 20;
}

var x = 10;
foo();

Output

undefined
undefined

Reason
Global x hoisted ‚Üí undefined

Function x hoisted ‚Üí undefined (shadowing)

---------------------------------------------------------------
Event Looping
---------------------------------------------------------------
It is the Mechanism which allows Javascript (single thread) to handle async operations

How it works?

It keep on check the call stack
if call stack is empty then it calls micotask after that Macrotask then repeat.

call stack(empty means) -> Micro task -> Macro task

Micro task
    Promise.then
    catch
    finally

Macro task
    setTimeout
    setInterval
    DOM events

micro task have HIGHER priority than Macrotask

Tricky Interview Questions (with answers üî•)
Q1Ô∏è) Predict the output
setTimeout(() => console.log("A"), 0);

Promise.resolve().then(() => console.log("B"));

console.log("C");

Output
C
B
A

Q2) What happens if microtasks keep coming?
    Macrotask waits
    UI can freeze

Q3) Is setTimeout guaranteed to run in given time?
    Ans - No

---------------------------------------------------------------
Hoisting
---------------------------------------------------------------
Hoisting is the process by which JavaScript allocates memory for variables and functions before code execution, allowing access to declarations before they appear in the code.

Note
    - Only declaration are hoisted
    - Initialization are not hoisted

- Hoisting with var

console.log(a);
var a = 10;
output -> undefined

- Hoisting with let and const

console.log(b);
let b = 20;

Output -> ReferenceError: Cannot access 'b' before initialization

Why?

let and const ARE hoisted

But kept in Temporal Dead Zone (TDZ)

Cannot be accessed before initialization

- Hoisting with Functions
hello();

function hello() {
  console.log("Hello");
}
‚úî Works
Why?
Function declarations are hoisted with full definition

- Difference between hoisting in functions and blocks?

var ‚Üí function-scoped

let/const ‚Üí block-scoped

---------------------------------------------------------------
undefiend + 1
---------------------------------------------------------------
The javascript tries to convert the undefiend to number because of the + operator it returns NAN that so the output will be NAN

Output:
NAN

---------------------------------------------------------------
Temporary Dead Zone TDZ
---------------------------------------------------------------

It is present in the memory execution phase where the let and const are allocated in memory but not accessable. If initial value is assigned means then we can access.
It will restrict the accessing the variable before accising an initial value.

---------------------------------------------------------------
Event Delegation
---------------------------------------------------------------

It is process of adding the vent lisners to the parent level instead of giving to its all child elements
Example :
const ul = document.querySelector("ul");

ul.addEventListener("click", (event) => {
  if (event.target.tagName === "LI") {
    console.log(event.target.textContent);
  }
});

---------------------------------------------------------------
call, apply and bind
---------------------------------------------------------------

these are used to control the 'this' value when calling a function

examples

call
const user :{
    name :"naveen"
}

function greet(){
    console.log(this.name)
} 

greet(user) -> undefiend

When we use call
greet.call(user); -> naveen

function greet(city, country) {
  console.log(this.name, city, country);
}

greet.call(user, "Chennai", "India");
‚úî Calls the function immediately
‚úî Arguments passed one by one

apply
syntax
greet.apply(this.Args,[arg1,arg2])

greet.apply(user, ["Chennai", "India"]);
‚úî Calls immediately
‚úî Arguments passed as array

bind (important)
const newFn = functioname.bind(this.Args,arg1,arg2)

const boundGreet = greet.bind(user, "Chennai", "India");

boundGreet();
‚úî Does NOT execute immediately
‚úî Returns a new function
‚úî Very useful in callbacks & React/Angular

Real-world example (very common)
without bind
const user :{
    name :"Naveen",
    greet(){
        setTimeout(function(){
            console.log(this.name);
        },1000)
    }
}

user.greet() ->undefined

with bind
 setTimeout(function(){
            console.log(this.name);
}.bind(this),1000)

Important note 
for array functions call,apply,bind does not work on then it always outputs undefiend

---------------------------------------------------------------
prototype
---------------------------------------------------------------
Prototype is an object where other object inherit properties and methods through the prototype chain

‚ùå Bad (duplicate methods):
const user1 = {
  greet() { console.log("Hi naveen"); }
};

const user2 = {
  greet() { console.log("Hi raj"); }
};


‚úÖ Good (shared via prototype):
function User(){
    this.name = name;
}

User.protoype.great = function(){
    console.log("Hi"+ this.name);
}

const user1 = new User("Naveen");
const user2 = new User("Raj");
Both objects share one greet method.

Prototype chain (VERY IMPORTANT üî•)

user1 -> User.prototype -> Object.prototype -> null

Example

function Person(){
    this.name = name;
}

Person.prototype.sayHi = fucntion(){
    console.log("Hi"+ this.name);
}

const p1 = new Person("Naveen");

p1.sayHi();

Flow:

p1 -> sayHi()
-> Checks Person.prototype
-> found -> excevuted

Prototype vs Class (important clarification)
class User {
  greet() {
    console.log("Hello");
  }
}

Behind the scenes:
User.prototype.greet

Object.create() & prototype

const parent = {
  role: "admin"
};

const child = Object.create(parent);

child.role; // "admin"
Behind the scenes:
child ‚Üí parent ‚Üí Object.prototype

---------------------------------------------------------------
Closure
---------------------------------------------------------------

Closure is when function remembers its variables from its outter scope even the outer function fineshed the exceution.

basic example

function outter(){
    let count = 0;

    funtion inner(){
        count++
        console.log("count");
    }
    return inner;
}

const inFn = outter();
inFn()
output -> 1

In Real life we can use it for Data privacy

function bankAccount() {
  let balance = 1000;

  return {
    deposit(amount) {
      balance += amount;
      console.log(balance);
    },
    getBalance() {
      return balance;
    }
  };
}

const account = bankAccount();

account.deposit(500); // 1500
console.log(account.balance); // ‚ùå undefined

setTimeout (Classic Interview Question)
function greet() {
  let name = "Naveen";

  setTimeout(function () {
    console.log(name);
  }, 1000);
}

greet();

Closure in Loops (FAMOUS INTERVIEW TRAP ‚ö†Ô∏è)
for (var i = 1; i <= 3; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}

output
4
4
4

Why?
var is function-scoped
One shared i
Closure captures reference, not value

Fix with let ‚úÖ
for (let i = 1; i <= 3; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
output
1
2
3
Because:

let creates new binding per iteration

Questions 
1) Do closures cause memory leaks?
Answer:
Yes, if not handled properly.
Variables stay in memory as long as closure exists.

---------------------------------------------------------------
Currying
---------------------------------------------------------------
Currying is a functional programming technique where a function takes arguments one at a time and returns a new function for the next argument.

Instead of this ‚ùå
add(2, 3)

We do this

add(2)(3)

Basic Example (Must-know)
function add(a){
    return function (b){
        return a + b;
    }
}

add(1)(2) // 3

Same Example with Arrow Function

const add = a => b => a + b;
add(5)(10); // 15

Use Case 1Ô∏è‚É£: Reusability (Very Important)

const multiply = a => b => a * b;

const double = multiply(2);
const triple = multiply(3);

double(5) // 2 * 5 => 10
triple(5) // 3 * 5 => 15

‚úîÔ∏è Create specialized functions
‚úîÔ∏è Reuse logic
‚úîÔ∏è Cleaner than passing same argument again and again

Use Case 2Ô∏è‚É£: Validation Functions
const minLength = length => value => value.length >= length;

const firstName = minLength(3);
const lastName = minLength(5);

firstName("na") //false
lastName("chandar") //true

---------------------------------------------------------------
Promise.race vs Promise.any
---------------------------------------------------------------

race -> Promise.race([p1, p2, p3])
it looks first promise which is settled that can be resolve or reject. first emits is considered

any -> Promise.any([p1, p2, p3])
it only looks for the success resolve not an reject response

example
race 
const p1 = new Promise((resolve)=> setTimeout(() => resolve("P1"),2000));
const p2 = new Promise((_,reject) => setTimeout(()=> reject("Error in P2"),1000));

Promise.race([p1, p2])
  .then(result => console.log(result))
  .catch(err => console.log(err));

output
Error in P2

Why?

p2 finished firstIt rejected
Race doesn‚Äôt care about success/failure

any
const p1 = new Promise((_, reject) => setTimeout(() => reject("Fail 1"), 1000));
const p2 = new Promise(resolve => setTimeout(() => resolve("Success"), 2000));

Promise.any([p1, p2])
  .then(result => console.log(result))
  .catch(err => console.log(err));

Why?

Ignores rejections
Resolves when first success happens

What if ALL promises fail in Promise.any?
Promise.any([
  Promise.reject("A"),
  Promise.reject("B")
])
.catch(err => console.log(err));

Output
AggregateError: All promises were rejected

‚úîÔ∏è Special error object
‚úîÔ∏è Contains all errors

---------------------------------------------------------------
Object.create vs Object.assign
---------------------------------------------------------------
Object.create
  ->It create object by prototype based
  -> It is accessed via prototype chain
  -> Example 
const person = {
  greet() {
    console.log("Hello");
  }
};

const user = Object.create(person);

user.name = "Naveen";

user.greet(); // Hello

What is happening?
-> user Object is created with person prototype
-> the user.greet method is accessed with parent
-> Prototype chain -> user-person
-> No property copying

Object.assign
  -> The new object is created with shallow copy.
  -> All the properties are copied
  -> Prototype is not changed 
  -> Example
const obj1 = { a: 1 };
const obj2 = { b: 2 };

const result = Object.assign({}, obj1, obj2);

console.log(result); // { a: 1, b: 2 }

But there will be shallow copy TRAP
const obj1 = { a: { x: 1 } };
const obj2 = Object.assign({}, obj1);

obj2.a.x = 99;

console.log(obj1.a.x); // 99 üò¨

---------------------------------------------------------------
Object.entries
---------------------------------------------------------------
It return the key and value in array format.
const user = {
  name: "Naveen",
  age: 28,
  role: "Frontend Developer"
};

console.log(Object.entries(user));

Output
[
  ["name", "Naveen"],
  ["age", 28],
  ["role", "Frontend Developer"]
]

Interview Question
const obj = Object.create({ a: 1 });
obj.b = 2;

console.log(Object.entries(obj));

Output
[["b", 2]]

It ignores prototype properties

---------------------------------------------------------------
Object.fromEntries
---------------------------------------------------------------
It is opposite of Object.entried

const arr = [
  ["name", "Naveen"],
  ["age", 28],
  ["role", "Frontend Developer"]
];

const obj = Object.fromEntries(arr);

console.log(obj);

Output
{
  name: "Naveen",
  age: 28,
  role: "Frontend Developer"
}

---------------------------------------------------------------
event.target vs event.currentTarget
---------------------------------------------------------------
target -> where the click is happened
currentTarget -> who is handling the click

example 
<div id="parent">
  <button id="child">Click</button>
</div>

parent.addEventListener("click", (event) => {
  console.log(event.target);        // button
  console.log(event.currentTarget); // div
});

---------------------------------------------------------------
async vs defer
---------------------------------------------------------------
example
1 -> <script src="app.js"></script>
2 -> <script async src="app.js"></script>
3 -> <script defer src="app.js"></script>

default case is 1 
-> HTML parsing is stopped
-> id app.js is large means , THe UI will looks like freeze

async case
-> Script loads asynchronously and executes as soon as it is ready, without guaranteeing order.

defer case
-> Script loads asynchronously but executes after HTML parsing, preserving order.

Real-World Use Cases
Use async when:
-> Script does not depend on DOM
-> Script does not depend on other scripts

‚úÖ Examples:
Google Analytics
Ads
Tracking scripts

Use defer when:
-> Script needs DOM access
-> Script depends on other scripts
You want predictable execution

‚úÖ Examples:
Main app JS

What happens if both async and defer are present?
Browser treats it as async

---------------------------------------------------------------
SOLID Principle
---------------------------------------------------------------
it is standard which will be followsed by developere to 
Write clean code
scalability
maintainbility

S -> Single Responsible
O -> open / closed
L -> Liskov Substitution
I -> Interface Segregation
D -> Dependency Inversion

1Ô∏è‚É£ S ‚Äì Single Responsibility Principle (SRP)
class / module should have only one reason to change.
‚ùå Bad Example
class UserService {
  createUser() {}
  sendEmail() {}
  saveToDatabase() {}
}
Too many responsibilities

Good Example
class UserService {
  createUser() {}
}

class EmailService {
  sendEmail() {}
}

class UserRepository {
  save() {}
}
‚úîÔ∏è Each class has one job

2Ô∏è‚É£ O ‚Äì Open / Closed Principle (OCP)
üëâ Code should be open for extension but closed for modification.

‚ùå Bad Example
function getDiscount(type: string) {
  if (type === "gold") return 20;
  if (type === "silver") return 10;
}
Every new type ‚Üí modify function ‚ùå
‚úÖ Good Example
interface Discount {
  getDiscount(): number;
}

class GoldDiscount implements Discount {
  getDiscount() {
    return 20;
  }
}

class SilverDiscount implements Discount {
  getDiscount() {
    return 10;
  }
}
Add new class, no modification üëå

3Ô∏è‚É£ L ‚Äì Liskov Substitution Principle (LSP)
üëâ Child class should replace parent class without breaking behavior.
‚ùå Bad Example
class Bird {
  fly() {}
}

class Penguin extends Bird {
  fly() {
    throw new Error("Can't fly");
  }
}
Breaks expectations ‚ùå

Good Example
‚úÖ Good Example
class Bird {}

class FlyingBird extends Bird {
  fly() {}
}

class Penguin extends Bird {
  swim() {}
}
‚úîÔ∏è No broken behavior

4Ô∏è‚É£ I ‚Äì Interface Segregation Principle (ISP)
üëâ Don‚Äôt force a class to implement methods it doesn‚Äôt need.
‚ùå Bad Example
interface Worker {
  work();
  eat();
}

class Robot implements Worker {
  work() {}
  eat() {} // üò¨
}

‚úÖ Good Example
interface Workable {
  work();
}

interface Eatable {
  eat();
}

class Robot implements Workable {
  work() {}
}
‚úîÔ∏è Small, focused interfaces

5Ô∏è‚É£ D ‚Äì Dependency Inversion Principle (DIP)
üëâ High-level modules should not depend on low-level modules, both should depend on abstractions.
‚ùå Bad Example
class MySQLDatabase {
  save() {}
}

class UserService {
  db = new MySQLDatabase();
}
Tightly coupled ‚ùå

‚úÖ Good Example
interface Database {
  save();
}

class MySQLDatabase implements Database {
  save() {}
}

class UserService {
  constructor(private db: Database) {}
}
‚úîÔ∏è Loose coupling
‚úîÔ∏è Easy to swap DB

Memory Trick üß†

S ‚Äì One job
O ‚Äì Add, don‚Äôt change
L ‚Äì Don‚Äôt break parent
I ‚Äì Don‚Äôt force methods
D ‚Äì Invert dependency

---------------------------------------------------------------
DRY Principles
---------------------------------------------------------------

DRY = Don‚Äôt Repeat Yourself
üëâ Every piece of knowledge or logic should exist in only one place in your codebase.

‚ùå Bad Example (DRY Violation)
function calculatePrice(price) {
  return price + price * 0.18;
}

function calculateDiscountedPrice(price) {
  return price + price * 0.18 - 100;
}
Tax logic repeated ‚ùå

‚úÖ Good Example (DRY Followed)
function addTax(price) {
  return price + price * 0.18;
}

function calculateDiscountedPrice(price) {
  return addTax(price) - 100;
}
‚úîÔ∏è Tax logic in one place

Is DRY always good?
 ‚úîÔ∏è Mostly yes
‚ùå But over-abstraction can reduce readability

---------------------------------------------------------------
Web Workers
---------------------------------------------------------------
Web Workers allow JavaScript to run in a background thread, separate from the main UI thread.

Why Do We Need Web Workers?
Without workers ‚ùå:
-> Heavy loops
-> Big calculations
->Data processing

üëâ UI becomes unresponsive

With workers ‚úÖ:
-> UI stays smooth
-> Heavy tasks run in background

Main Thread vs Web Worker
Main Thread	Web Worker
Handles UI->	No UI access
DOM access->	‚ùå No DOM
Blocking possible->	Non-blocking
Event handling->	Background tasks

we have two methods
‚úîÔ∏è postMessage ‚Üí send data
‚úîÔ∏è onmessage ‚Üí receive result

Common Interview Traps ‚ö†Ô∏è
‚ùì Can Web Worker access DOM?
‚ùå No

‚ùì Can Web Worker communicate with main thread?
‚úîÔ∏è Yes, via postMessage

‚ùì Are Web Workers asynchronous?
‚úîÔ∏è Yes

When should you NOT use Web Workers?
-> Small tasks
-> DOM manipulation
-> Frequent UI updates

---------------------------------------------------------------
class vs prototype
---------------------------------------------------------------
Js is working based on the prototype
Prototype is the Mechanism where the javascript object inherit properties and methods from the other objects.

function Person(){
  this.name = name;
}

Person.prototype.sayHi = function(){
  console.log("Hi"+ this.name)
}

const p1 = new Person("Naveen");
p1.sayHi();

Class
it provides clean and familiar syntax on top of prototype

class Person {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    console.log("Hi " + this.name);
  }
}

const p1 = new Person("Naveen");
p1.sayHi();

Are They Different Internally?
‚ùå No
‚úîÔ∏è Both use prototypes internally

Key Differences (Interview Table üî•)
Feature	Prototype	Class
Syntax	Function-based	Cleaner, OOP-style
Readability	Harder	Easier
Hoisting	Function hoisted	‚ùå Not hoisted

---------------------------------------------------------------
iterators
---------------------------------------------------------------
It is the object and which we can loop through one by one on demand.
it will return an object as {value:any,done:boolean}

Example: Built-in Iterator

const arr = [10,20,30,40];
const iterator = arr[Symbol.iterator]();

console.log(iterator.next()); // { value: 10, done: false }
console.log(iterator.next()); // { value: 20, done: false }
console.log(iterator.next()); // { value: 30, done: false }
console.log(iterator.next()); // { value: undefined, done: true }

Where Iterators are used automatically?

These use iterators internally:

for...of
Spread operator ...
Array.from()

---------------------------------------------------------------
generators
---------------------------------------------------------------
Generator is the special function that 
can pause the execution
resume it later
after pause we will get the iterator as return automatically

functions number(){
  yield 1;
  yield 2;
  yield 3;
}

const gens = numbers();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }

yield = pause + return value

Generator with for...of
function* fruits() {
  yield "apple";
  yield "banana";
  yield "mango";
}

for (let fruit of fruits()) {
  console.log(fruit);
}

Real-World Use Cases (Very Important for Interviews)
‚úÖ 1. Lazy Loading / Large Data
function* infiniteNumbers() {
  let i = 1;
  while (true) {
    yield i++;
  }
}
üëâ Generates values only when needed

---------------------------------------------------------------
high order function
---------------------------------------------------------------

It is a function where it that operates on other functions by taking them as argument or return of the function

simple example - function as agrument

function greet(name){
  return "Hi" + name;
}

function welcome(fn){
  return fn("Naveen");
}

console.log(welcome(greet))
‚úî welcome is a higher-order function
‚úî greet is a callback function

simple example - function return another function

function multiplier(number){
  return function(times){
    return times * number;
  }
}

const double = multiplier(5);
console.log(double(2)) //10

‚úî multiplier is a HOF
‚úî This is also closure + currying

Built-in Higher-Order Functions (VERY IMPORTANT)

These are classic interview answers:

üîπ map()
const nums = [1, 2, 3];

const squares = nums.map(n => n * n);
console.log(squares); // [1, 4, 9]
map, filter, reduce are pure higher-order functions

HOF vs Callback (Common Confusion)
Term	Meaning
Higher-Order Function	Function that accepts/returns functions
Callback Function	Function passed to another function

---------------------------------------------------------------
Array methods
---------------------------------------------------------------

Adding / Removing Elements (Mutates Array ‚ö†Ô∏è)
üîπ push() ‚Äì add at end
arr.push(4);

üîπ pop() ‚Äì remove from end
arr.pop();

üîπ unshift() ‚Äì add at start
arr.unshift(0);

üîπ shift() ‚Äì remove from start
arr.shift();

üîπ join()
["a", "b", "c"].join("-"); // "a-b-c"

üîπ split() (string method but related)
"a-b-c".split("-"); // ["a", "b", "c"]

üîπ some()

üëâ At least one element matches

[1, 2, 3].some(n => n > 2); // true

üîπ every()

üëâ All elements match

[1, 2, 3].every(n => n > 0); // true

Mutating vs Non-Mutating

‚ùå Mutating ‚Üí push, pop, splice, sort

‚úÖ Non-mutating ‚Üí map, filter, slice, reduce

---------------------------------------------------------------
Slice vs Splice
---------------------------------------------------------------

Slice
It return a new array
Does not change the original array

syntax
arr.slice(start,end previous value) -> (1,3) -> means start 1 index end with 3 before value

const arr = [1, 2, 3, 4, 5];

const result = arr.slice(1, 4);

console.log(result); // [2, 3, 4]
console.log(arr);    // [1, 2, 3, 4, 5]

Omitting the end parameter
const fruits = ["Apple", "Banana", "Orange", "Mango", "Pineapple"];

const tropical = fruits.slice(2);
console.log(tropical); // ['Orange', 'Mango', 'Pineapple']

Using negative indices

const fruits = ["Apple", "Banana", "Orange", "Mango", "Pineapple"];

const lastTwo = fruits.slice(-2);
console.log(lastTwo); // ['Mango', 'Pineapple']

Splice
Changes the original array
can remove, add or replace the elements
return the removed elements

Syntax
array.splice(start, deleteCount, item1, item2, ...)
Remove elements
const arr = [1, 2, 3, 4, 5];

const removed = arr.splice(1, 2);

console.log(removed); // [2, 3]
console.log(arr);     // [1, 4, 5]

Add elements user 0 in the delectecounts

const arr = [1, 2, 4];

arr.splice(2, 0, 3);

console.log(arr); // [1, 2, 3, 4]

Replace elements use 1 in the delectecounts

const arr = [1, 2, 3];

arr.splice(1, 1, 99);

console.log(arr); // [1, 99, 3]

---------------------------------------------------------------
flat vs flatmap
---------------------------------------------------------------

flat
it flatten the nested array
-> return the new array
-> does not modify the original array

Syntax
array.flat(depth)

depth is how deep the flattern should happened


const arr = [1,[2,[3,4]]];
console.log(arr.flat(1)); // [1, 2, [3, 4]]
console.log(arr.flat(2)); // [1, 2, 3, 4]

Use Infinity to flatten fully:
arr.flat(Infinity);

flatMap() ‚Äì Map + flat (depth = 1)
üëâ What it does

First maps each element

Then flattens one level

Equivalent to: array.map().flat(1)

When to Use What? (Interview Answer)

Use flat() when:

You already have nested arrays

You only want to flatten

Use flatMap() when:

You want to transform + flatten

Avoid extra map().flat() call

---------------------------------------------------------------
DebounceTime vs ThrottleTime
---------------------------------------------------------------

DebounceTime ‚Äì ‚ÄúWait till user stops‚Äù
üëâ What it does
-> Waits for silence
-> Executes only after events stop for given time
-> If events keep coming ‚Üí timer resets

ex:
function debounce(fn, delay) {
  let timer;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

const search = debounce((text) => {
  console.log("API call:", text);
}, 500);

Throttle
  -> Runs once per time window
  -> Exceute at most one time at give  interval of time.

 function throttle(fn,limit){
  let inThrottle = false;

  return function(...args){
    if(!inThrottle){
      fn.apply(this,args);
      inThrottle = true;
      setTimeout(()=> inThrottle=false,limit)
    }
  }
 } 

 const onScroll = throttle(() => {
  console.log("Scroll event");
}, 1000);

üîπ Scrolling continuously
üëâ Runs once every 1 second